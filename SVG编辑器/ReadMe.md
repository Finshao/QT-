> 总体 介绍 ，框架部分 亮点部分 问题与解决方案

# SVGEditor

## 一. 总体介绍

基于QT框架实现的SVG编辑器，可实现SVG文件编辑的基本功能以及SVG文件的保存，导出，打开查看。

![未命名文件1](./未命名文件(1).png)

## 二. 设计思路

1. **图形绘制：**
   
   1. **五角星**：五角星有10个点位，根据100*100大小内正五角星的坐标信息按比例处理获得相对标准的正五角星
   
   2. **自由线**：要依靠大量point来描绘，其他图形均只依靠矩形区域即可描绘，所以要记录List<Point>
   
   3. **文本**：
      
      > * 显示依靠一个矩形
      > 
      > * 编辑依靠画布内的textedit来编辑数据并传回矩形

2. **参数栏**
   
   1. **画布相关参数**
      
      1. 宽，高，颜色
      
      2. 缩放比例
      
      > * 在mainwindows内的参数调整函数里，设置 输入调整比例
      > 
      > * 在svgmianwindow内，重写wheelevent事件，调整比例
      > 
      > * 在svgmainwindows里，事件结束后发动信号给miandows
      > 
      > * maindows接收信号后更新m_pCanvasParamsBar里对应缩放的lineEdit
   
   2. **shape相关参数**
      
      1. 边框宽度，填充颜色，边框颜色
      
      > * 为shape添加对应属性，描绘会根据属性
      > 
      > * 为canvas添加当前shape处理属性，当触发事件时更新内容
      > 
      > * 当创建新shape或shape被选中是可以根据canvas属性修改自己内部属性
      
      2. 边框样式
      
      > * 自定义控件kdownbox, 包含一个下拉框
      > 
      > * style属性，对应Qt::PenStyle属性
   
   3. **画布倍率与绘画内容的同步**
      
      > * 不改变shape内point，而是以scale倍率绘画
      > 
      > * canvas内鼠标的选中获取也要按照scale倍率
      > 
      > * 移动距离要除以倍率
   
   4. **修改shape样式**: 当处于选中状态时，触发事件后将currentshape属性改为canvas内更新后的参数栏属性。

3. **文件菜单栏**
   
   1. **SVGFile类**：保存了当前画布的所有信息，包含画布信息，以及shapelist
      
      > * 通过KGobal和canvas获取到数据，深拷贝shape避免对象销毁数据丢失
      > 
      > * svgFile对象：位于kmainwindow内，用于保存当前需要的画布数据
      > 
      > * fileList<SVGFile>: 保存多个svgfile，用于撤回重做
   
   2. **新建文件**：canvas参数改为默认值，shapelist，filelist清空，刷新画布
   
   3. **打开svg**：（未完成，采用了简化的处理方式）
      
      > * 解析svg文件
      > 
      > * 解析数据存入svgfile对象
      > 
      > * 操作svgfile对象重置画布属性
   
   4. **保存**：（未完成，采用了简化的处理方式）
      
      > * svgfile获取当前画布数据
      > 
      > * 根据svgfile生成对应格式svg文件
   
   5. **导出png**：调用api获取画布截屏快照，保存本地

4. **右键菜单栏**
   
   1. **全选**
      
      > * 设置全选标识m_selectAllShape
      > 
      > * 右键触发后标识置为true，取消false全选与m_select逻辑一致（比如：绘画时，光标press时找不到shape时）
      > 
      > * move：与单个shape区别：要遍历所有shape，所以没遍历完前lastpo不做更新
      > 
      > * 样式：根据全选标识，优先级大于m_select, 会进行所有shape样式一起更改
   
   2. **复制，删除，剪切，粘贴**
      
      > * m_buff存放复制，剪切内容
      > 
      > * 删除会释放shape空间，从shapelist移除
      > 
      > * 复制：深拷贝shape
      > 
      > * 剪切：复制 + 删除
      > 
      > * 粘贴：将buff数据深拷贝到shapelist，postion加（10，10）偏移量
   
   3. **撤销复写**
      
      > * 根据上文提到的filelist对象，在所需记录的操作前，通过SVGFile获取画布内容，插入filelist
      > 
      > * index，指向当前画布对应filelist位置
      > 
      > * 插入操作：删除index后面的数据，再插入，因为按照逻辑：如果撤回过，再进行操作会覆盖掉可重做的范围，即无法重做
      > 
      > * 撤销：重置为index - 1位置画布状态
      > 
      > * 重做：重置为index + 1位置画布状态
   
   4. **图层**
      
      > * 设置图层0-6七层，默认shape都是第3层
      > 
      > * 修改paintevent函数，改变draw顺序，从第6层开始绘画，第0层会最后绘画，显示在最上边
      > 
      > * 处理右键菜单对应逻辑功能注：同一图层的绘画顺序还是根据shapelist，更改显示状态的最好办法就是放在不同图层，个人感觉7个图层够用了，太多会影响paintevent的绘画时间性能

## 三. 问题与解决

1. 自由线无法移动
   
   > 从头到尾debug了一遍都没发现问题，最后花了很长时间才发现自己基础不牢固，犯了一个低级错误，在KPen的移动函数里，我使用了for(auto a : m+posVector)这导致+=pos, 没有改变坐标，因为是拷贝到参数。。。

2. 文本编辑
   
   > 最开始尝试在shape里创造textEdit，但是其父类类型QPaintor无法包容组件尝试在Kcanvas画布里创建一个textEdit来作为编辑窗口，每当触发双击事件时，根据event.pos()获取shape信息，textEdit根据信息show，这样”看起来“我们的静态绘画就可以编辑了，之后就是传递数据重绘等等。

3. 边框颜色的edit之后无反应，debug不到问题
   
   > 底层为KValueBox，其内部正则表达式拦截了小于10的输入，而因为是边框，我几乎一直在10内测试所以没有反应更改正则表达式拦截条件

4. 空指针异常
   
   > * 深拷贝时，错误的将使用：对象指针 = 旧的对象指针，导致旧指针delete后报错
   > 
   > * 改为：*对象指针 = *旧的对象指针 正确调用赋值运算符

## 四. 优化

1. **全选**
   
   > 为全选状态加入了shape的边框宽度，颜色，样式和填充颜色的修改提高了用户体验

2. **图层**默认实现方式是更改当前shape在shapelist里的位置，但是这会存在问题：
   
   > 1. 当画布中存在很多shape时，里面有很多覆盖存在，而互相覆盖的shape在list里相邻可能性很小，意味着当我们想要改变二者之间的状态（如：将一个被覆盖的shapeA显示在覆盖他的shapeB的上面），我们要操作很多很多次才能达到效果（每次shapeA在list里移动一位，直到和shapeB的顺序发生变化）
   > 
   > 2. 当画布中存在很多shape时，每个shape一个图层，上百的图层对于有清晰层次的画布来说很糟糕
   
   总之，这两个问题用户体验很差，所以我才用了以下实现方式：
   
   > * 设置图层0-6七层，默认shape都是第3层
   > 
   > * 修改paintevent函数，改变draw顺序，从第6层开始绘画，第0层会最后绘画，显示在最上边
   > 
   > * 注：同一图层的绘画顺序还是根据shapelist，更改显示状态的最好办法就是放在不同图层，目前设置为7个图层，太多会影响paintevent的绘画时间性能
   
   通过这个实现处理掉了存在的问题。拷贝

3. **SVGFile类**
   
   1. **撤消重做**
      
      > 这里svgfile储存了整个画布的数据，根据其就可还原一个画布状态，所以undo/redo可以很方便的将任务要求的所有操作改变状态无需区分，统一记录画布存放在一个list里即可
      > 统一了undo/redo的访问接口，更加方便规范
   
   2. **文件菜单**
      
      > * 在svg文件的打开和保存时，会涉及到画布的所有信息
      > 
      > * 我们可以将svgfile作为一个统一的数据接口，
      > 
      > * 保存文件时，将数据统一保存其中，在集中访问数据生成svg文件
      > 
      > * 打开文件时，要解析svg文件，解析到的多种数据，可以统一存入svfile，再在后续的绘制时访问
      
      由此可见，svg为程序架构提供了一个规范，方便的访问接口

4. **拷贝与删除**
   
   > 为了避免空指针异常问题，svgfile保存shape选择分配新空间
   > 删除操作的shape，进行delete，因为脱离shapelist，将会无管制导致内存泄漏

## 五. 存在问题

1. 窗口初始化后，先点击填充颜色，描绘的shape无颜色（已处理）
   
   > 令shape的绘画依赖于自身的成员变量属性，个性化处理

2. 滚轮缩放从一开始变化（已处理）
   
   > kgobal内本身有scale，又定义了一个，使用紊乱了

3. 快捷键无反应（已处理）
   
   > 重写keyPressEvent函数

4. 粘贴不是根据鼠标位置(已处理)
   
   > 还未完全优化，目前为粘贴函数为上一个shape偏移pos(10, 10)的位置

5. 全选状态下的 删除剪切复制粘贴 还未实现

6. Text文本只有在选中状态可以正常运行
   
   > 当进入编辑状态时，鼠标点击其他位置，text将进入非选中状态，这是enter结束编辑文本将传输失效

7. 缩放比例后shape移动和鼠标移动未匹配

8. 前文设计思路提到的保存和打开svg方法还未完全实现，时间来不及，采用了相对简单的实现方式
